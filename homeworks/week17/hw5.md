## 這週學了一大堆以前搞不懂的東西，你有變得更懂了嗎？請寫下你的心得。

在學習這門課程的時候是滿滿的期待，因為終於到達了 JavaScript 中階的部份了。我個人是很喜歡深入探討原理的，因為懂原理比任何只懂流程都好非常非常多。

懂原理的話，實際上在理解事情上面，可以做更好的學習，將來也比較不容易忘記。這就讓我回想到以前還是學生的時候，我對於理科可以有非常深入的理解，所以理科的成績一直都不錯。而我文科真的不行到一種很誇張的地步，主要是傳統教育上面往往都是死背硬記。

尤其是歷史、國文，這兩個部份，我在就學時期要說有多討厭，就有多討厭。結果畢業之後到了大學，反而因為一些遊戲引起我的興趣。我反而變成有一些歷史狂，因為不再是讀書考試要用的，整體之間在查資料的時候，就可以看到一些脈絡，很多事情是有起因，有結果，是什麼樣的原因，才導致歷史走向這樣走。

甚至也會思考一下，到底如果當時產生的問題有什麼更好的解決方法嗎？都會做諸如此類的思考。

國文則是現在進行式，我每週都會去的課程，因為是讀資料，雖然說都是中文，實際上字詞我們在使用的時候都誤解了，或是濫用。這是很嚴重的一件事，因為會導致人學習不下去。所以就會需要查清楚字詞的意思，甚至也要去理解來由，學習到最後，有時候讓人覺得簡直就是在讀國文一樣。

這樣是有很大的好處，因為這樣子做可以提升智慧，在思考很多事情的時候，可以讓我們更加清楚的知道什麼是什麼，這也是為什麼西方可以很進步的原因，仔細去看看他們的字典，像是劍橋辭典會發現，跟中文的字典相比較之下，中文很多字詞的定義其實都很模糊，甚至是 A 詞的定義就用 B 詞來解釋，結果去找 B 詞，B 詞的定義用 A 詞來解釋，整體就是跟沒解釋一樣。為此我還要常常去找多本字典才可以看到比較好的解釋。

### 主軸
離題了，把主題拉回來。所以我真的滿喜歡深入理解原理，在這裡的部份，我把 JavaScript 的底層做了很完整的理解。

從 execution context 到作用域這兩個大重點，從這邊才可以知道 closure、hoisting 等的原理，以及產生的原因。所以我就可以只用一套 execution 跟 context 去打天下了，就不用特別去硬記那些規則到底是什麼了。

因為這種硬記只會很容易就忘掉了，說實在的，當我在 \[Week17] 重新學習到 hoisting 的部份，我早就把規則都忘光了。甚至想不太起來 hoisting 到底是什麼意思。


### hoisting 
在 hoisting 的部份我記得，剛開始學習的時候，我是很認為自己是知道的、理解的，因為前面在看直播影片的時候，我都是答對的，結果 \[Week17] 提供的文章，老師的例子稍微不一樣一點我就答錯了。

這就再次印證，硬記真的不行的。而通過 execution context 的理解之後，就可以更好的明白為什麼 hoisting 的規則會是如此，所以實際上不是直接產生 hositing 的機制，而是有底層的 Execution context 產生 hoisting 的機制。

也因為如此的機制，所以 JavaScript 才可以在當時被設計為一個新手導向的程式語言吧？而這點在後面學習的 prototype 的時候，又逐步的透露出更多針對新手的設計方式。


### closure
closure 的部份，我可以大致理解到是為什麼產生這樣子原理。在這裡又再次的理解 execution context 跟 Scope chain 的問題，要產生一個不會被回收的變數，又不會被 global 修改，是要怎麼實現的。也就是使用 function 中的 function 才可以讓 VO 不會被回收。

而在 closure 的部份，也講到 IIFE 原來就是這簡單哦！馬上可以執行的 Function 這部份在 \[JS102] 還是 \[JS101] 的時候，就有看到老師利用了，所以知道有這種方法，只是在這邊才清楚原來整體是這樣子的。


### 物件導向
物件導向的部份，則是要明白當初作者為什麼會這樣子設計 JavaScript 的物件導向。目的就是要讓 JavaScript 成為一個新手易學的程式語言。

所以 JavaScript 的 new 是直接連結到建構子（建構函式）的，然後在通過其他的方法共用資訊。而這個方法就是 prototype chain。

通過 prototype chain 就可以把很多的資料串在一起。而 prototype chain 的理解，我認為是一大進步。所以這部份我也花了最多的時間去理解，也看了不少的資訊。

也因為前面已經理解的 scope chain，所以在理解 prototype chain 到底是什麼樣的東西，就會比較清晰。就是一個可以讓程式查詢資料的方式，而 prototype chain 就是讓物件導向可以共用資訊的方法。

相比之下 prototype chain 還可以添加一些變數或 function 進去，這是與 scope chain 比較不一樣的地方。


### this 
最後是 this 的部份，這部份因為有前面的基礎，所以就簡單的多了。

雖然說之前看到很多人的文章都把 this 講的好像非常複雜的那種感覺。所以進到這部份說實在我還有點怕怕的XD。

結果實際上跟我們想的真的不一樣，這不也只是 JavaScript 這個程式語言的一部分而已嗎？再複雜也沒有人類的行為複雜。

放下這種成見之後來看，才發現實際上也不難。只是分類比較分歧，必須要看的面向比較多。

但也只是幾個重點而已。
1. 跟物件無關的部份，就是看環境，看是 window / global 或是嚴格模式的 undefined
2. 在物件導向就是指 instance 本身。
3.  物件底下就是看 `.call`  的參數，主要跟 function 怎麼呼叫有關係。

記住這幾個重點， this 就會比較簡單一些。


### event loop
從 Philip Roberts 的影片中可以清楚的看到 event loop 是怎麼運作的。event loop 本身就是解決 JavaScript 的 single thread 運行效率的方法。

通過這個機制可以很有效的運用 JavaScript 的效能。而我們也需要他去找尋代辦事項，然後把代辦事項給 call stack 處理。

event loop 平常主要執行 call stack 裡面的內容。當 call stack 的內容清空之後，才會去 call queue 去找有無 webAPIs 返回的指令，或是 render queue 的指令，雖然我沒看到有說還有其他的 queue，不過我想應該還是會有其他種類的 queue 吧？

而 queue 的部份則是直接會把東西放到 call stack，然後等 call stack 處理完畢之後，才又再去找尋其他的 queue 有無需要處理的部份。

這部份跟我一開始學習 Event loop 的時候想的不太一樣。

所以真的很多東西都要自己實際下去運作、練習才可以發現到底是什麼地方有問題。

### 作業部份
通過這些作業，我覺得例子都很好。可以讓我們深入的去理解到底是怎麼運作的。就像是通過這樣的例子，我們可以把這些 JavaScript 比較底層的部份，做一個更好的學習。

在作業實作的部份，可能因為前面的學習，所以解答的時候，都還滿順利的，這讓我感覺還滿好的。

我只是比較擔心自己不夠好，所以就是有點邊寫邊直接執行看看這樣子。

也要慶幸自己有這樣子的習慣，所以在 This 那題就發現到一些問題。該題的 `hello()` 疑似不算是物件，所以他的 this 是 window 或 global ，這樣看環境。嚴格模式就是 undefined

也的確還多時候 this 還是跟我們想得不一樣。

作業的其他部份，讓人有一種興奮感。每發現自己答對一次，就可以明白自己真的有把東西學進去。 

