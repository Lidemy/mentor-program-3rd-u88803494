# Week3 解題思考、想法、心得
 

## 前言

因為這周有測試系統，而我自己其實也覺得很多東西要學廣一點，所以是額外開個資料夾把這周的預設檔案放進去，然後開始寫，可能也會試著寫測試等通過測試之後再把正確的給提交吧！



## hw1：好多星星


對於這題的想法，很明顯就是需要回傳一個陣列，所以會需要一個迴圈，然後依序 .push 添加結果。最後回傳 arr。

心得：覺得這題就是之前的 \[JS101]  的星星題目的微變化題型，所以很快就想出來了。


## hw2：大小寫互換


一個個判斷大小寫之後改寫添加進新變數，然後回傳變數。

心得：就是判斷跟迴圈還有添加而已，覺得還滿容易想的。



## hw3：判斷質數

就是判斷質數，之前寫過了，但是這邊因為在練習先寫測試再寫 code 所以花了一些時間再找更大的質數，好方便測試。

[質數列表](https://www.shuxuele.com/numbers/prime-numbers-to-10k.html)

心得:為了這一題我還去找了一堆的測資來測試，可能對質數這題比較不熟，明明就有打出正確的程式碼卻覺得有點懷疑，特地跑去回溫了一下，好在最後還是順利的解出來了。

## hw4：判斷迴文

最開始的想法是一個個比較，但突然想到如果字串長度是奇數的話，好像有點難比較，後來想想有奇數的話中間就不用判斷了，後來想法是寫一個 function 回傳反過來的字串，之後再把這個 function 回傳的值與字串作比較，如果一樣的話就回傳 true。

本來想試試看能不能直接把字串反傳於是直接使用 reverse 但發現不行，查過之後原來他只能反轉陣列，所以就把字串切開再反轉再結合就可以反轉了。

後來想到題目沒定義大小寫問題，但是因為定義那邊說用念的，所以一般人在念的時候並不會特別強調是大小寫，所以就再加個轉小寫之後再來判斷。
  
心得：其實一開始的想法果然也是偏向於複雜型的，後面就想超簡單，直接反轉之後再判斷有沒有一樣就好了啊...所以也是很快就寫出來了。


### hw5：大數加法

預先想了一下大數加法的做法，目前想到兩個方向，一是拆成陣列之後各自相加，最後再用 .join 串在一起之後回傳。第二種是位元運算的方法，初步猜想是把每個位元給相加之後轉換 10 進位再回傳。

因為傳入的是字串所以要先把字串轉成數字，而且直式加法是由最後一位開始往前加數字的，從後面往前數最後一個陣列是個位數，次後一個是十位數，依此類推，所以可能要另外開一個 function 來單一計算之後再回傳乘 10。

  

本來有顧慮到加法長度不同的問題，但是看題目都沒寫，而且也想到要作長度不同的話，轉換上也有難度，因為還必須要把較短的一方填上 0 才可以相加，不過這一點可以先忽略，假定題目都是給同樣的位數。這樣會比較容易思考。

測試之後發現，大數直接儲存之後呼叫都沒辦法印出正確值，所以超過一定的範圍就必須要轉成字串，不然會無法正確儲存，即使把大數後來再轉成字串也一定不會回傳正確的值，所以就必須要避免數字太大。

轉數字，arrA[0] = parseInt(arrA[0])，如果原來是數字經過處理也還是數字。

所以我是不是應該：

1.  寫一個 function 把字串轉成陣列，再轉型態為數字。
2.  寫一個 function 把較短的一方補上 0。可能的話要把陣列反轉以方便添加0。
3.  寫一個 function 把對應的陣列相加。
4.  寫一個每提升一位就*10 的 function。
5.  寫個判斷大於 9 就處理進位的 function

先把字串反轉，然後從 index 0 開始帶入 function 1，然後送到 function 3 相加，返回後根據 index 0 開始每 +1 就 *10 之後回傳

目標是想一位一位相加，要處理的點是進位，進位要用判斷式來判斷，如果大於 9 就利用 function 5

  

後來發現可以利用先完成的字串擺後面，新計算出來的擺前面，直接作字串相加，就可以少去位數的處理步驟。

```
var a1 = '5' // 第一個運算完成  
var a2 = '4' // 第二個運算完成  
var a = a2 + a1  
console.log(a)  
//45
```
  

修正

1.  寫一個 function 把字串轉成陣列。
2.  寫一個 function 把陣列反轉後，把較短的一方補上 0，直到兩邊的長度等於最長的一邊+1。
3.  寫一個 function 把對應的陣列轉型態為數字，再相加，再轉成字串回傳。
4.  寫個 function 判斷有沒有大於 9，有的話進位處理。這好像不適合寫成function。
5.  從 index 0 開始把 index n 放後面與 index n+1 相加，達成位數的累積。

  

判斷大小的時候字串可以跟數字相比。
```
a = ‘10’  
if (a > 9) {  
console.log(‘yes’)  
}  
// yes
```
  

最後的處理：（一邊解一邊寫出來解到哪）

1.  直接把字串拆開之後反轉，並賦值新陣列變數名稱。
2.  判斷誰比較長，取得較長的為變數 length。
3.  寫一個 function 添加 0，次數可以用 length - 該陣列的長度來計算，把這個 function 加入步驟 2 的判斷式裡面。
4.  開始寫迴圈，判斷只要全部的數字相加之後小於 10，直接相加，大於10 則進位處理。

  

思考如何處理進位？

額外做一個進位的變數，只要判斷有進位，就把這個變數賦值 1，然後再與 function 3 相加，後面思考進位處理還是需要另外的 function 會比較好。

利用一個進位變數只要有進位就改值為 1，然後下次的輪迴就可以添加 1。進位處理要另外寫過，判斷該進位時候，就在下一輪進位，進位完之後進位值歸零。

迴圈中一開始就要先把 index 0 相加，然後再判斷是不是需要進位，需要則把進位變數 = 1，然後下一輪的時候才可以相加，下一輪，相加後，再判斷需不需要進位，需要把進位變成 = 1。

  

卡了半天的進位處理，結果居然從 debugger 抓出來，真是感謝 chrome 的神工具。原來我再判斷的時候忘記把進位變數一起放進去判斷了，導致我判斷出來的結果一直有問題，所以才會再相加的時候一直出問題。後來修正完成之後，結果 all right。然後我就感到很錯愕，居然在這種小地方卡了兩個小時，不過大致上我還是覺得很爽，因為終於解出答案來了！
  
心得：大數加法果然很難，從一開始想的思路其實通通都是不可行的道路，好在有老師的提示，所以就依照該方向一邊想一邊測試，最終還是讓我給解出來了，而且不管看幾次都覺得應該沒問題，果然在上傳 OJ 的時候就直接看到 AC，虧我還緊張了一下下，結果 All right，太棒了！



# 整體

收穫：在這些題目之中，大多數其實都已經做過了，所以還滿快就得到解答了，大致就是之前解過的小變化題而已。當然 hw5 就不一樣了，算是完全沒解過的題目，也的確滿難的，從一開始以為就應該沒太困難，所以覺得還好的態度，然後一跳進來研究之後，越研究才發現的確是很多地方需要克服，就也認知到這的確是個有難度的題目，所幸在提示之下跟我的努力解析，最終還是作出像樣的回答了，感覺十分良好。